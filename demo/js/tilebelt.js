
var d2r = Math.PI / 180,
    r2d = 180 / Math.PI;

/**
* Get the bbox of a tile
*
* @name tileToBBOX
* @param {Array<number>} tile
* @returns {Array<number>} bbox
* @example
* var bbox = tileToBBOX([5, 10, 10])
* //=bbox
*/
function tileToBBOX(tile) {
    var e = tile2lon(tile[0] + 1, tile[2]);
    var w = tile2lon(tile[0], tile[2]);
    var s = tile2lat(tile[1] + 1, tile[2]);
    var n = tile2lat(tile[1], tile[2]);
    return [w, s, e, n];
}

/**
* Get a geojson representation of a tile
*
* @name tileToGeoJSON
* @param {Array<number>} tile
* @returns {Feature<Polygon>}
* @example
* var poly = tileToGeoJSON([5, 10, 10])
* //=poly
*/
function tileToGeoJSON(tile) {
    var bbox = tileToBBOX(tile);
    var poly = {
        type: 'Polygon',
        coordinates: [[
            [bbox[0], bbox[3]],
            [bbox[0], bbox[1]],
            [bbox[2], bbox[1]],
            [bbox[2], bbox[3]],
            [bbox[0], bbox[3]]
        ]]
    };
    return poly;
}

function tile2lon(x, z) {
    return x / Math.pow(2, z) * 360 - 180;
}

function tile2lat(y, z) {
    var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
    return r2d * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
}

/**
* Get the tile for a point at a specified zoom level
*
* @name pointToTile
* @param {number} lon
* @param {number} lat
* @param {number} z
* @returns {Array<number>} tile
* @example
* var tile = pointToTile(1, 1, 20)
* //=tile
*/
function pointToTile(lon, lat, z) {
    var tile = pointToTileFraction(lon, lat, z);
    tile[0] = Math.floor(tile[0]);
    tile[1] = Math.floor(tile[1]);
    return tile;
}

/**
* Get the 4 tiles one zoom level higher
*
* @name getChildren
* @param {Array<number>} tile
* @returns {Array<Array<number>>} tiles
* @example
* var tiles = getChildren([5, 10, 10])
* //=tiles
*/
function getChildren(tile) {
    return [
        [tile[0] * 2, tile[1] * 2, tile[2] + 1],
        [tile[0] * 2 + 1, tile[1] * 2, tile[2] + 1],
        [tile[0] * 2 + 1, tile[1] * 2 + 1, tile[2] + 1],
        [tile[0] * 2, tile[1] * 2 + 1, tile[2] + 1]
    ];
}

/**
* Get the tile one zoom level lower
*
* @name getParent
* @param {Array<number>} tile
* @returns {Array<number>} tile
* @example
* var tile = getParent([5, 10, 10])
* //=tile
*/
function getParent(tile) {
    return [tile[0] >> 1, tile[1] >> 1, tile[2] - 1];
}

function getSiblings(tile) {
    return getChildren(getParent(tile));
}

/**
* Get the 3 sibling tiles for a tile
*
* @name getSiblings
* @param {Array<number>} tile
* @returns {Array<Array<number>>} tiles
* @example
* var tiles = getSiblings([5, 10, 10])
* //=tiles
*/
function hasSiblings(tile, tiles) {
    var siblings = getSiblings(tile);
    for (var i = 0; i < siblings.length; i++) {
        if (!hasTile(tiles, siblings[i])) return false;
    }
    return true;
}

/**
* Check to see if an array of tiles contains a particular tile
*
* @name hasTile
* @param {Array<Array<number>>} tiles
* @param {Array<number>} tile
* @returns {boolean}
* @example
* var tiles = [
*     [0, 0, 5],
*     [0, 1, 5],
*     [1, 1, 5],
*     [1, 0, 5]
* ]
* hasTile(tiles, [0, 0, 5])
* //=boolean
*/
function hasTile(tiles, tile) {
    for (var i = 0; i < tiles.length; i++) {
        if (tilesEqual(tiles[i], tile)) return true;
    }
    return false;
}

/**
* Check to see if two tiles are the same
*
* @name tilesEqual
* @param {Array<number>} tile1
* @param {Array<number>} tile2
* @returns {boolean}
* @example
* tilesEqual([0, 1, 5], [0, 0, 5])
* //=boolean
*/
function tilesEqual(tile1, tile2) {
    return (
        tile1[0] === tile2[0] &&
        tile1[1] === tile2[1] &&
        tile1[2] === tile2[2]
    );
}

/**
* Get the quadkey for a tile
*
* @name tileToQuadkey
* @param {Array<number>} tile
* @returns {string} quadkey
* @example
* var quadkey = tileToQuadkey([0, 1, 5])
* //=quadkey
*/
function tileToQuadkey(tile) {
    var index = '';
    for (var z = tile[2]; z > 0; z--) {
        var b = 0;
        var mask = 1 << (z - 1);
        if ((tile[0] & mask) !== 0) b++;
        if ((tile[1] & mask) !== 0) b += 2;
        index += b.toString();
    }
    return index;
}

/**
* Get the tile for a quadkey
*
* @name quadkeyToTile
* @param {string} quadkey
* @returns {Array<number>} tile
* @example
* var tile = quadkeyToTile('00001033')
* //=tile
*/
function quadkeyToTile(quadkey) {
    var x = 0;
    var y = 0;
    var z = quadkey.length;

    for (var i = z; i > 0; i--) {
        var mask = 1 << (i - 1);
        var q = +quadkey[z - i];
        if (q === 1) x |= mask;
        if (q === 2) y |= mask;
        if (q === 3) {
            x |= mask;
            y |= mask;
        }
    }
    return [x, y, z];
}

/**
* Get the smallest tile to cover a bbox
*
* @name bboxToTile
* @param {Array<number>} bbox
* @returns {Array<number>} tile
* @example
* var tile = bboxToTile([ -178, 84, -177, 85 ])
* //=tile
*/
function bboxToTile(bboxCoords) {
    var min = pointToTile(bboxCoords[0], bboxCoords[1], 32);
    var max = pointToTile(bboxCoords[2], bboxCoords[3], 32);
    var bbox = [min[0], min[1], max[0], max[1]];

    var z = getBboxZoom(bbox);
    if (z === 0) return [0, 0, 0];
    var x = bbox[0] >>> (32 - z);
    var y = bbox[1] >>> (32 - z);
    return [x, y, z];
}

function getBboxZoom(bbox) {
    var MAX_ZOOM = 28;
    for (var z = 0; z < MAX_ZOOM; z++) {
        var mask = 1 << (32 - (z + 1));
        if (((bbox[0] & mask) !== (bbox[2] & mask)) ||
            ((bbox[1] & mask) !== (bbox[3] & mask))) {
            return z;
        }
    }

    return MAX_ZOOM;
}

/**
* Get the precise fractional tile location for a point at a zoom level
*
* @name pointToTileFraction
* @param {number} lon
* @param {number} lat
* @param {number} z
* @returns {Array<number>} tile fraction
* var tile = pointToTileFraction(30.5, 50.5, 15)
* //=tile
*/
function pointToTileFraction(lon, lat, z) {
    var sin = Math.sin(lat * d2r),
        z2 = Math.pow(2, z),
        x = z2 * (lon / 360 + 0.5),
        y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);

    // Wrap Tile X
    x = x % z2;
    if (x < 0) x = x + z2;
    return [x, y, z];
}

var tilebelt = {
    tileToGeoJSON: tileToGeoJSON,
    tileToBBOX: tileToBBOX,
    getChildren: getChildren,
    getParent: getParent,
    getSiblings: getSiblings,
    hasTile: hasTile,
    hasSiblings: hasSiblings,
    tilesEqual: tilesEqual,
    tileToQuadkey: tileToQuadkey,
    quadkeyToTile: quadkeyToTile,
    pointToTile: pointToTile,
    bboxToTile: bboxToTile,
    pointToTileFraction: pointToTileFraction
};