<!DOCTYPE html>
<html>

<head>
    <title>vectortile test</title>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/geojson-vt@3.2.1/geojson-vt.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.6/build/dat.gui.min.js"></script>
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/maptalks/dist/maptalks.css">
    <script type="text/javascript" src="./js/maptalks.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/three@0.109.0/build/three.min.js"></script>
    <script type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/maptalks.three@latest/dist/maptalks.three.js"></script>
    <script type="text/javascript" src="./js/mvttogeojson.bundle.js"></script>
    <script type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/three@0.109.0/examples/js/libs/stats.min.js"></script>
    <script type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/three-text2d@0.5.3/dist/three-text2d.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/rbush@3.0.1/rbush.min.js"></script>
    <style>
        html,
        body {
            margin: 0px;
            height: 100%;
            width: 100%;
        }

        #map {
            width: 100%;
            height: 100%;
            background-color: #000;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script>

        var baseLaer = new maptalks.TileLayer('tile', {
            urlTemplate: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
            subdomains: ['a', 'b', 'c', 'd'],
            attribution: '&copy; <a href="http://osm.org">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/">CARTO</a>'
        });
        var map = new maptalks.Map("map", {
            center: [120.18174266554763, 30.477290641604526],
            zoom: 18.2,
            pitch: 60,
            // pitch: 60,
            // bearing: 180,

            centerCross: true,
            doubleClickZoom: false,
            baseLayer: baseLaer,
            zoomControl: {
                'position': 'bottom-left'
            }
        });

        baseLaer.on('layerload', function () {
            // console.log('layerload');
        })

        /** ----------for maptalks.thre------------*/
        maptalks.ThreeLayer.prototype.texts = [];
        maptalks.ThreeLayer.prototype.rbush = new RBush();

        maptalks.ThreeLayer.prototype.collides = function () {
            this.rbush.clear();
            for (let i = 0, len = this.texts.length; i < len; i++) {
                const text = this.texts[i];
                const textRect = text.getTextRect();
                if (this.rbush.collides(textRect)) {
                    text.hide();
                } else {
                    text.show();
                    this.rbush.insert(textRect);
                }
            }
        }


        maptalks.ThreeLayer.prototype.toText = function (coordinate, options) {
            return new TextSprite(coordinate, options, this);
        }


        // @Override
        maptalks.ThreeLayer.prototype._zoomend = function () {
            const scene = this.getScene();
            if (!scene) {
                return;
            }
            const zoom = this.getMap().getZoom();
            scene.children.forEach(mesh => {
                const parent = mesh.__parent;
                if (parent && parent.getOptions) {
                    if (!parent.getOptions().zoomFilter) {
                        return;
                    }
                    const minZoom = parent.getMinZoom(), maxZoom = parent.getMaxZoom();
                    if ((zoom < minZoom || zoom > maxZoom) && parent.isVisible()) {
                        parent.hide();
                    } else if (minZoom <= zoom && zoom <= maxZoom && (!parent.isVisible())) {
                        parent.show();
                    }
                }
            });
        }

        // @Override
        maptalks.ThreeLayer.prototype.addMesh = function (meshes, render = true) {
            if (!meshes) return this;
            if (!Array.isArray(meshes)) {
                meshes = [meshes];
            }
            const scene = this.getScene();
            meshes.forEach(mesh => {
                if (mesh instanceof maptalks.BaseObject) {
                    scene.add(mesh.getObject3d());
                    if (!mesh.isAdd) {
                        mesh.isAdd = true;
                        mesh._fire('add', { target: mesh });
                        if (mesh instanceof TextSprite) {
                            this.texts.push(mesh);
                            const textRect = mesh.getTextRect();
                            if (threeLayer.rbush.collides(textRect)) {
                                mesh.hide();
                            } else {
                                mesh.show();
                                threeLayer.rbush.insert(textRect);
                            }
                        }
                    }
                    if (mesh._animation && maptalks.Util.isFunction(mesh._animation)) {
                        this._animationBaseObjectMap[mesh.getObject3d().uuid] = mesh;
                    }
                } else if (mesh instanceof THREE.Object3D) {
                    scene.add(mesh);
                }
            });
            this._zoomend();
            // sort by weight
            this.texts.sort(function (text1, text2) {
                return text2.getOptions().weight - text1.getOptions().weight;
            });
            this.collides();
            if (render) {
                this.renderScene();
            }
            return this;
        }

        /**
         * remove object3ds
         * @param {BaseObject} meshes
         */
        // @Override
        maptalks.ThreeLayer.prototype.removeMesh = function (meshes, render = true) {
            if (!meshes) return this;
            if (!Array.isArray(meshes)) {
                meshes = [meshes];
            }
            const scene = this.getScene();
            meshes.forEach(mesh => {
                if (mesh instanceof maptalks.BaseObject) {
                    scene.remove(mesh.getObject3d());
                    if (mesh.isAdd) {
                        mesh.isAdd = false;
                        mesh._fire('remove', { target: mesh });
                        if (mesh instanceof TextSprite) {
                            for (let i = 0, len = this.texts.length; i < len; i++) {
                                if (mesh === this.texts[i]) {
                                    this.texts.splice(i, 1);
                                    break;
                                }
                            }
                        }
                    }
                    if (mesh._animation && maptalks.Util.isFunction(mesh._animation)) {
                        delete this._animationBaseObjectMap[mesh.getObject3d().uuid];
                    }
                } else if (mesh instanceof THREE.Object3D) {
                    scene.remove(mesh);
                }
            });
            // sort by weight
            this.texts.sort(function (text1, text2) {
                return text2.getOptions().weight - text1.getOptions().weight;
            });
            this.collides();
            if (render) {
                this.renderScene();
            }
            return this;
        }


        /** ---------------------------------------*/

        // the ThreeLayer to draw buildings
        var threeLayer = new maptalks.ThreeLayer('t', {
            forceRenderOnMoving: true,
            forceRenderOnRotating: true
            // animation: true
        });


        var vectortilelayer, tileIndex;
        threeLayer.prepareToDraw = function (gl, scene, camera) {
            stats = new Stats();
            stats.domElement.style.zIndex = 100;
            document.getElementById('map').appendChild(stats.domElement);

            var light = new THREE.DirectionalLight(0xffffff);
            light.position.set(0, -10, 10).normalize();
            scene.add(light);

            // const worker = new Worker('./js/worker.three.js');
            const url = `http://localhost/{z}/{x}/{y}`;
            vectortilelayer = threeLayer.toThreeVectorTileLayer(url,
                {
                    // minZoom: 6,
                    // maxZoom: 16,
                    // debug: true,
                    interactive: false,
                    subdomains: ['a', 'b', 'c', 'd'],
                },
                getMaterial);
            // vectortilelayer.debug = true;

            vectortilelayer.onSelectMesh = onSelectMesh;

            vectortilelayer.getTileData = function (q) {
                const { key, url, callback, img } = q;
                const splitstr = key.includes('_') ? '_' : '-';
                let [id, y, x, z] = key.split(splitstr);
                x = parseInt(x);
                y = parseInt(y);
                z = parseInt(z);
                var tile = tileIndex.getTile(z, x, y);//.features;
                if (tile) {
                    // console.log(tile);
                    var pbfdata = geojsonTile2Pbf('road', tile);
                    const geojson = mvt2GeoJSON(pbfdata, x, y, z)
                    callback(key, geojson, img);
                } else {
                    callback(key, null, img);
                }
            }

            fetch('./data/line.json').then(res => res.json()).then(geoJSON => {
                tileIndex = geojsonvt(geoJSON, {
                    debug: 1,
                    maxZoom: 20
                });
                map.addLayer(vectortilelayer);
                // request a particular tile

            });

            // 文字
            fetch('./data/text.json').then(res => res.json()).then(chinacitys => {
                addSprites(chinacitys);
            });

            animation();
            initGui();


        };
        threeLayer.addTo(map);


        function createLightMateria() {
            const canvasDom = document.createElement('canvas');
            const size = 32;
            canvasDom.width = size;
            canvasDom.height = size;
            const ctx = canvasDom.getContext('2d');
            const gradient = ctx.createRadialGradient(
                canvasDom.width / 2,
                canvasDom.height / 2,
                0,
                canvasDom.width / 2,
                canvasDom.height / 2,
                canvasDom.width / 2);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.005, 'rgba(139,69,19,1)');
            gradient.addColorStop(0.4, 'rgba(139,69,19,1)');
            gradient.addColorStop(1, 'rgba(0,0,0,1)');

            ctx.fillStyle = gradient;
            ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
            ctx.fill();
            console.log(canvasDom.toDataURL());

            // ctx.fillRect(0, 0, canvasDom.width, canvasDom.height);

            const texture = new THREE.Texture(canvasDom);
            texture.needsUpdate = true; //使用贴图时进行更新
            return texture;
        }

        //高亮材质
        const roadhighMaterial = new THREE.LineDashedMaterial({
            linewidth: 1,
            color: 'yellow',
            // opacity: 0.8,
            transparent: true,
            dashSize: 0.05,
            gapSize: 0.05
        });
        const buildhighMaterial = new THREE.MeshBasicMaterial({ color: 'yellow', transparent: true });
        const pointhighMaterial = new THREE.PointsMaterial({
            // size: 10,
            sizeAttenuation: false,
            color: 'yellow',
            // alphaTest: 0.5,
            // vertexColors: THREE.VertexColors,
            //  transparent: true
            // color: 0xffffff,
            size: 10,
            transparent: true, //使材质透明
            // blending: THREE.AdditiveBlending,
            depthTest: true, //深度测试关闭，不消去场景的不可见面
            depthWrite: false,
            //刚刚创建的粒子贴图就在这里用上
        });

        //事件处理
        var selectMesh = [];
        function onSelectMesh(type, e) {
            // console.log(type);
            // console.log(e.target);
            const { target } = e;
            const select = e.selectMesh;
            if (type === 'empty' && selectMesh.length) {
                // if (selectMesh) {
                threeLayer.removeMesh(selectMesh);
                selectMesh = [];
                // }
                return;
            }

            let data, baseObject;
            if (select) {
                data = select.data;
                baseObject = select.baseObject;
                if (baseObject && (!baseLaer.isAdd)) {
                    // console.log(baseObject);
                    // if (selectMesh) {
                    //     threeLayer.removeMesh(selectMesh);
                    // }
                    const meshType = baseObject.getType();
                    if (meshType.includes('Polygon')) {
                        baseObject.setSymbol(buildhighMaterial);
                    } else if (meshType.includes('Line')) {
                        baseObject.setSymbol(roadhighMaterial);
                    } else if (meshType.includes('Point')) {
                        baseObject.setSymbol(pointhighMaterial);
                    }
                    threeLayer.addMesh(baseObject);
                    selectMesh.push(baseObject);
                    // selectMesh = baseObject;
                }
            }
            if (selectMesh.length > 20) {
                threeLayer.removeMesh(selectMesh);
                selectMesh = [];
            }
            // override tooltip
            if (type === 'mousemove' && data) {
                let tooltip = target.getToolTip();
                if (!tooltip) {
                    target.setToolTip(target.getId(), {
                        showTimeout: 0,
                        eventsPropagation: true,
                        dx: 10
                    });
                    tooltip = target.getToolTip();
                }
                const id = baseObject.getId();
                tooltip._content = `id:${id}`;
            }
            //override infowindow
            if (type === 'click' && data) {
                let infoWindow = target.getInfoWindow();
                if (!infoWindow) {
                    target.setInfoWindow({
                        content: '',
                        title: 'message',
                        animationDuration: 0,
                        autoOpenOn: false
                    });
                    infoWindow = target.getInfoWindow();
                }
                const id = baseObject.getId();
                infoWindow.setContent(`id:${id}`);
                if (infoWindow && (!infoWindow._owner)) {
                    infoWindow.addTo(this);
                }
                target.openInfoWindow(e.coordinate);
            }
        }


        const roadMaterial = new THREE.LineBasicMaterial({ color: 'rgb(43,69,107)', transparent: true, opacity: 1 });
        const waterMaterial = new THREE.MeshBasicMaterial({ color: 'green', transparent: true });
        const waterwayMaterial = new THREE.LineBasicMaterial({ color: 'green', transparent: true, opacity: 1 });
        const buildMaterial = new THREE.MeshPhongMaterial({ color: '#fff', transparent: true });
        const pointMaterial = new THREE.PointsMaterial({
            // size: 10,
            sizeAttenuation: false,
            // color: fillStyle,
            // alphaTest: 0.5,
            // vertexColors: THREE.VertexColors,
            //  transparent: true
            // color: 0xffffff,
            size: 5,
            transparent: true, //使材质透明
            // blending: THREE.AdditiveBlending,
            depthTest: true, //深度测试关闭，不消去场景的不可见面
            depthWrite: false,
            map: createLightMateria()
            //刚刚创建的粒子贴图就在这里用上
        });
        const poiMaterial = new THREE.PointsMaterial({
            // size: 10,
            sizeAttenuation: false,
            // color: fillStyle,
            // alphaTest: 0.5,
            // vertexColors: THREE.VertexColors,
            //  transparent: true
            // color: 0xffffff,
            size: 20,
            transparent: true, //使材质透明
            // blending: THREE.AdditiveBlending,
            depthTest: true, //深度测试关闭，不消去场景的不可见面
            depthWrite: false,
            map: new THREE.TextureLoader().load('./data/1.svg')
        });

        function getMaterial(layerName, data, key, geojson) {
            // console.log(layerName, data);
            switch (layerName) {
                case 'water': {
                    return waterMaterial;
                }
                case 'waterway': {
                    return waterwayMaterial;
                }
                case 'road': {
                    return roadMaterial;
                }
                // case 'building': {
                //     return buildMaterial;
                // }
                // case 'water': {
                //     if (data[0] instanceof maptalks.LineString) {
                //         // return waterlineMaterial;
                //     } else if (data[0] instanceof maptalks.Polygon || data[0] instanceof maptalks.MultiPolygon) {
                //         return waterMaterial
                //         // return pointMaterial;
                //     } else {

                //     }
                // }
                // case 'place_label': {
                //     return poiMaterial;
                // }
                case 'poi_label': {
                    return pointMaterial;
                }

                default: {
                    return null;
                }
            }

        }


        function animation() {
            // layer animation support Skipping frames
            threeLayer._needsUpdate = !threeLayer._needsUpdate;
            if (threeLayer._needsUpdate) {
                threeLayer.renderScene();
                threeLayer.collides();
            }
            stats.update();
            requestAnimationFrame(animation);
            if (params.rotate) {
                map.setBearing(map.getBearing() + 0.1);
            }

        }


        var params = {
            add: true,
            buildingColor: buildMaterial.color.getStyle(),
            buildingOpacity: 1,
            animateShow: animateShow,

            waterColor: waterMaterial.color.getStyle(),
            waterOpacity: 1,

            roadColor: roadMaterial.color.getStyle(),
            roadOpacity: 1,

            pointSize: pointMaterial.size,
            blending: false,

            show: true,
            altitude: 0,
            rotate: false,
            interactive: false
        };

        function initGui() {

            var gui = new dat.GUI();
            gui.add(params, 'add').onChange(function () {
                if (params.add) {
                    map.addLayer(vectortilelayer);
                } else {
                    map.removeLayer(vectortilelayer);
                }
            });
            // gui.addColor(params, 'buildingColor').name('buildingColor').onChange(function () {
            //     buildMaterial.color.set(params.buildingColor);
            // });
            // gui.add(params, 'buildingOpacity', 0, 1).onChange(function () {
            //     buildMaterial.opacity = params.buildingOpacity;
            // });


            // gui.addColor(params, 'waterColor').name('waterColor').onChange(function () {
            //     waterMaterial.color.set(params.waterColor);
            // });
            // gui.add(params, 'waterOpacity', 0, 1).onChange(function () {
            //     waterMaterial.opacity = params.waterOpacity;
            // });


            gui.addColor(params, 'roadColor').name('roadColor').onChange(function () {
                roadMaterial.color.set(params.roadColor);
            });
            gui.add(params, 'roadOpacity', 0, 1).onChange(function () {
                roadMaterial.opacity = params.roadOpacity;

            });


            // gui.add(params, 'blending').onChange(function () {
            //     if (params.blending) {
            //         pointMaterial.blending = THREE.AdditiveBlending;
            //     } else {
            //         pointMaterial.blending = THREE.NoBlending;
            //     }
            // });
            // gui.add(params, 'pointSize', 2, 20).onChange(function () {
            //     pointMaterial.size = params.pointSize;
            // });



            gui.add(params, 'show').onChange(function () {
                if (params.show) {
                    vectortilelayer.show();
                } else {
                    vectortilelayer.hide();
                }
            });
            gui.add(params, 'altitude', 0, 300).onChange(function () {
                const meshs = vectortilelayer.getBaseObjects();
                meshs.forEach(function (mesh) {
                    mesh.setAltitude(params.altitude);
                });
            });
            // gui.add(params, 'animateShow');
            gui.add(params, 'rotate');
            gui.add(params, 'interactive').onChange(function () {
                vectortilelayer._opts.interactive = params.interactive;
                const meshs = vectortilelayer.getBaseObjects();
                meshs.forEach(function (mesh) {
                    mesh.options.interactive = params.interactive;
                });
            });
        }

        function animateShow() {
            const meshs = vectortilelayer.getBaseObjects();
            meshs.forEach(function (mesh) {
                mesh.animateShow({
                    duration: 1300
                });
            });
        }

        /** ----------------------------------------------------------*/
        map.on('click', (evt) => {
            console.log(evt)
        });

        map.on('zooming zoomend moveend animateend', () => {
            threeLayer.collides();
        });

        //default values
        var OPTIONS1 = {
            fontSize: 20,
            altitude: 0,
            color: '#fff',
            text: 'hello',
            weight: 0,
            zoomFilter: false
        };


        class TextSprite extends maptalks.BaseObject {
            constructor(coordinate, options, layer) {
                options = maptalks.Util.extend({}, OPTIONS1, options, { layer, coordinate });
                super();
                //Initialize internal configuration
                // https://github.com/maptalks/maptalks.three/blob/1e45f5238f500225ada1deb09b8bab18c1b52cf2/src/BaseObject.js#L135
                this._initOptions(options);
                const { altitude, fontSize, color, text } = options;


                //Initialize internal object3d
                // https://github.com/maptalks/maptalks.three/blob/1e45f5238f500225ada1deb09b8bab18c1b52cf2/src/BaseObject.js#L140
                this._createGroup();
                const textsprite = new THREE_Text2D.SpriteText2D(text, { align: THREE_Text2D.textAlign.center, font: `${fontSize * 2}px Arial`, fillStyle: color, antialias: false });
                textsprite.children[0].material.sizeAttenuation = false;
                const scale = 0.01 / 10 / 3;
                textsprite.scale.set(scale, scale, scale);
                this.getObject3d().add(textsprite);

                //set object3d position
                const z = layer.distanceToVector3(altitude, altitude).x;
                const position = layer.coordinateToVector3(coordinate, z);
                this.getObject3d().position.copy(position);
                this.textRect = {
                    width: this.calTextWidth(text, fontSize),
                    height: fontSize
                }

                this._vector = new THREE.Vector3();
                this._pixel = {
                    x: 0,
                    y: 0
                };
            }

            getTextRect() {
                this.getPixel();
                const { x, y } = this._pixel;
                const { width, height } = this.textRect;
                return {
                    minX: x - width / 2,
                    minY: y - height / 2,
                    maxX: x + width / 2,
                    maxY: y + height / 2
                }
            }

            calTextWidth(text, fontSize) {
                const chinese = text.match(/[\u4e00-\u9fa5]/g) || '';
                const chineseLen = chinese.length;
                const width = chineseLen * fontSize + (text.length - chineseLen) * 0.5 * fontSize;
                return width;
            }

            getPixel() {
                const size = this.getMap().getSize();
                const camera = this.getLayer().getCamera();
                const position = this.getObject3d().position;
                this._vector.x = position.x;
                this._vector.y = position.y;
                this._vector.z = position.z;
                this._pixel = simplepath.vector2Pixel(this._vector, size, camera);
            }

            identify(coordinate) {
                const { minX, minY, maxX, maxY } = this.getTextRect();
                const pixel = this.getMap().coordToContainerPoint(coordinate);
                if (pixel.x >= minX && pixel.x <= maxX && pixel.y >= minY && pixel.y <= maxY) {
                    return true;
                }
                return false;
            }
        }


        var simplepath = {

            positionsConvert: function (worldPoints, altitude = 0, layer) {
                const vectors = [];
                for (let i = 0, len = worldPoints.length; i < len; i += 3) {
                    let x = worldPoints[i], y = worldPoints[i + 1], z = worldPoints[i + 2];
                    if (altitude > 0) {
                        z += layer.distanceToVector3(altitude, altitude).x;
                    }
                    vectors.push(new THREE.Vector3(x, y, z));
                }
                return vectors;
            },

            vectors2Pixel: function (worldPoints, size, camera, altitude = 0, layer) {
                if (!(worldPoints[0] instanceof THREE.Vector3)) {
                    worldPoints = simplepath.positionsConvert(worldPoints, altitude, layer);
                }
                const pixels = worldPoints.map(worldPoint => {
                    return simplepath.vector2Pixel(worldPoint, size, camera);
                })
                return pixels;

            },

            vector2Pixel: function (world_vector, size, camera) {
                const vector = world_vector.project(camera);
                const halfWidth = size.width / 2;
                const halfHeight = size.height / 2;
                const result = {
                    x: Math.round(vector.x * halfWidth + halfWidth),
                    y: Math.round(-vector.y * halfHeight + halfHeight)
                };
                return result;
            },

        };


        var textSprites = [];
        function addSprites(res) {


            let provinceMarkers = [];
            res.features.map(fea => {
                provinceMarkers.push({
                    name: fea.properties.TEXT,
                    coordinates: fea.geometry.coordinates
                })
            })

            provinceMarkers.forEach(element => {
                textSprites.push(threeLayer.toText(element.coordinates, { text: element.name, color: 'red', fontSize: 20, weight: 2, interactive: false }));
            });

            threeLayer.addMesh(textSprites);
            animation();
        }





        /** ----------------------------------------------------------*/
    </script>
</body>

</html>